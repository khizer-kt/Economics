// hashing
#pragma once
#include "orders.h"
#include "LinkedList.h"
#include "avl_tree.h"
#include <iostream>
#include <cmath>


using namespace std;


class hashing{
	public: 
		int size;
		orders * hash_table; 
		hashing(int x);
		void append_h(orders o);
		int hash_func(const char* str);
		void print_h();
};



hashing :: hashing(int x){
	hash_table = new orders[x];
	}
int hashing::hash_func(const char* str) {
  int loc = 5381;
  int c;

  while ((c = *str++)) {
    loc = ((loc << 5) + loc) + c;  // hash * 33 + c
  }

  return loc;
}


void hashing :: append_h(orders o){ 
		int x= hash_func("Hello! World");
		
		if(hash_table[x].next== nullptr){
			hash_table[x]=o;

			
		}
		else{
			tree t1;
			t1.insert(o);
			o.next=t1.root;
		
			
		}
// Allocate a new node and set its data
//Node* new_node = new Node(data);
//        if (head == NULL) {
//            // If the list is empty, set the new node as the head and tail of the list
//            head = new_node;
//            tail = new_node;
//        }
//        else {
//            // Otherwise, set the next pointer of the current tail of the list to the new node
//            tail->next = new_node;
//            // Then set the tail of the list to the new node
//            tail = new_node;
//
        }


//void hashing::print_h() {
//        for (int i = 0; i < content.size(); i++) {
//        	cout<<hash_table[i];
//        }
//    	cout<<endl;
//    }



// hashing 



// orders 

#pragma once
#include "LinkedList.h"
#include "avl_tree.h"
#include <iostream>

using namespace std;


class orders{
	public:
		string order_desc;
		node *next;
		orders();
		
};

orders::orders(){
	order_desc=" ";
	next=nullptr;

}


// orders 


//avl

#pragma once
#include <iostream>
#include "hash.h"
using namespace std;


class node{
	public:
		int data;
		node *lchild;
		node *rchild;
		node(){
			data=0;
			lchild=nullptr;
			rchild=nullptr;
		}
};
class tree{
	public:
		node *loc;
		node *ploc;
		node *root;
		int count_leaf;
		int count_node;
		int height;
		int h_left;
		int h_right;
	
		tree(){
			loc=nullptr;
			ploc=nullptr;
			root=nullptr;
			count_leaf=0;
			count_node=0;
			height=0;
			h_left=0;
			h_right=0;
	
		}
		bool is_empty(){
			if (root == nullptr){
				return true;
			}
			else{
				return false;
			}
		}
		void search(int value){
			loc=root;
			ploc=nullptr;
			while(loc!=nullptr and loc->data!=value){
				ploc=loc;
				if (loc->data<value){
					loc=loc->rchild;
				}
				else if(loc->data>value){
					loc=loc->lchild;
				}
			}
			
		}
		void insert(int value){
			search(value);
			if (loc==nullptr){
				node *nn=new node();
				nn->data=value;
				if (ploc!=nullptr){
					if(ploc->data<value){
						ploc->rchild=nn;
					}
					else if (ploc->data>value){
						ploc->lchild=nn;
					}
				}
				else if(ploc==nullptr && root==nullptr){
					root=nn;
				}
			}
			else{
				cout<<"value already exist"<<endl;
			}
			
		}
		void pre_print(node *root){
			if(root==nullptr){
				return ;
			}
			else{
				cout<<root->data<<endl;
				pre_print(root->lchild);
				pre_print(root->rchild);
			}
		}
//		void in_print(node *root){
//			if(root==nullptr){
//				return ;
//			}
//			else{
//				pre_print(root->lchild);
//				cout<<root->data<<endl;
//				pre_print(root->rchild);
//			}
//		}
//		void post_print(node *root){
//			if(root==nullptr){
//				return ;
//			}
//			else{
//				pre_print(root->lchild);
//				pre_print(root->rchild);
//				cout<<root->data<<endl;
//			}
//		}
//		int smallest(node *root){
//			if(root->lchild!=nullptr){
//				smallest(root->lchild);
//			}
//			else{
//				return root->data;
//			}
//		}
//		int largest(node *root){
//			if(root->rchild!=nullptr){
//				largest(root->rchild);
//			}
//			else{
//				return root->data;
//			}
//		}
//		void print_leaf(node *root){
//			if (root!=nullptr){
//				if (root->lchild==nullptr && root->rchild==nullptr){
//					cout<<root->data<< " ";
//				}
//				print_leaf(root->lchild);
//				print_leaf(root->rchild);
//			}
//			else{
//				return ;
//			}
//			
//		}
//		void count_leaves(node *root){
//			if (root!=nullptr){
//				if (root->lchild==nullptr && root->rchild==nullptr){
//					count_leaf++;
//				}
//				count_leaves(root->lchild);
//				count_leaves(root->rchild);	
//			}
//			else{
//				return ;
//			}
//		}
//		void count_nodes(node *root){
//			if(root!=nullptr){
//				if (root->lchild!=nullptr && root->rchild!=nullptr){
//					count_node++;
//				}
//				count_nodes(root->lchild);
//				count_nodes(root->rchild);
//			}
//			else{
//				return ;
//			}
//		
//		}
		int height_tree(node *root){
			if (root==nullptr){
				return height;
			}
			if(root->lchild!=nullptr or root->rchild!=nullptr){
				height++;
			}
			height_tree(root->lchild);
			height_tree(root->rchild);
				
		}
		int height_differ(node *root){
			
			h_left=height_tree(root->lchild);
			h_right=height_tree(root->rchild);
			
			return h_left-h_right;
			
		}
		void avl_converter(node *root,node *parent){
			int x=height_differ(root);
			if (x==+2){
				node *x=root;
				node *y;
				y=x->lchild;
				int h_right1=height_tree(root->rchild->rchild);
				int h_left1=height_tree(root->rchild->lchild);
				if (h_right1 +1 == h_left1){
					node *x1;
					node *y1;
					x1=y;
					y1=y->rchild;
					y->rchild=y1->lchild;
					y1->lchild=y;
					y=y1;
				}
				
				x->lchild=y->rchild;
				y->rchild=x;
				if (parent!=nullptr){
					if(parent->lchild==x){
						parent->lchild=y;
					}
					else if(parent->rchild==x){
						parent->rchild=y;
					}
				}
				else{
					root=y;
				}
				
				
			}
			if (x==-2){
				node *x=root;
				node *y;
				y=x->rchild;
				int h_right1=height_tree(root->rchild->rchild);
				int h_left1=height_tree(root->rchild->lchild);
				if (h_left1 +1 == h_right1){
					node *x1;
					node *y1;
					x1=y;
					y1=y->lchild;
					y->lchild=y1->rchild;
					y1->rchild=y;
					y=y1;
					
				}
				
				x->rchild=y->lchild;
				y->lchild=x;
				if (parent!=nullptr){
					if(parent->lchild==x){
						parent->lchild=y;
					}
					else if(parent->rchild==x){
						parent->rchild=y;
					}
				}
				else{
					root=y;
				}
			}
				
		}
		void avl(node *root,node *parent){
			if (root!=nullptr){
				avl(root->lchild,root);
				avl(root->rchild,root);
				int x=height_differ(root);
				if(x==2 or x==-2){
					avl_converter(root,parent);
				}
			}
			else{
				cout<<" "<<endl;
			}
		}
	
	
};





// avl 



// parser 

#pragma once
#include "LinkedList.h"
#include "hash.h"
#include "orders.h"
#include "avl_tree.h"
using namespace std;



void parse_all(hashing h) {
	orders r;
    string fname;
    cout << "Enter the file name: ";
    cin >> fname;

    vector<vector<string>> content;
    vector<string> row;
    string line, word;

    fstream file(fname, ios::in);
    if (file.is_open()) {
        while (getline(file, line)) {
            row.clear();

            stringstream str(line);

            while (getline(str, word, ','))
                row.push_back(word);
            content.push_back(row);
        }
    }
    else {
        cout << "Could not open the file\n";
    }

    // Use the append function to insert the data read from the file into the list
    for (int i = 0; i < content.size(); i++) {
        //for (int j = 0; j < content[i].size(); j++) {
        	r.order_desc=content[i][1];
//        	r.order_desc=content[i][j];
	        h.append_h(r);
       // }
        
    }
    cout<<endl;
}


// parser 
